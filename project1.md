# 온라인 인적성 검사 Back Office 

기존 오프라인 중심의 인적성 검사 환경에서 온라인 전환이 가속화됨에 따라, **인적성 검사 운영 전 과정을 통합 관리** 할 수 있는 온라인 플랫폼 구축 프로젝트입니다.

**개요**

기존 오프라인 중심의 인적성 검사 환경에서 온라인 전환이 가속화됨에 따라,

검사 운영 전 과정을 디지털화하고 통합 관리할 수 있는 온라인 플랫폼 프로젝트입니다.

### 트러블 슈팅1

**Web Worker를 활용한 API Fetching**

**문제 상황**

- 공고 조회 시 기응시자 여부를 확인하는 과정에서 API 요청이**30초 이상 Pending** 되는 경우가 발생했습니다.
- 이로 인해 메인 스레드가 블로킹되며 **UI가 프리징**되는 심각한 문제로 이어졌습니다.결과적으로 운영팀이 다른 작업을 동시에 진행하지 못하는 불편함이 있었습니다.

**해결 과정**

**Web Worker**

도입 → 기응시자 포함 공고 조회 API 요청을 백그라운드 스레드에서 처리하도록 변경했습니다.

•	메인 스레드와 Worker 간 postMessage / onmessage 비동기 통신을 구현했습니다.

•	API 호출 대기 시간 동안

**Skeleton UI**

를 적용하여 사용자 경험을 개선했습니다.

•	Worker의 생명주기 관리 및 에러 핸들링 로직을 구축하여 안정성을 확보했습니다.

**성과**

- 공고 조회 시 UI 프리징 문제가 해소되어, 운영팀이 다른 작업을 동시에 원활하게 수행할 수 있게 되었습니다.
- 시스템 응답성이 개선되어 운영팀의 업무 효율성이 눈에 띄게 향상되었습니다.

**배운점**

- Web Worker와 같은 브라우저 제공 기능을 활용하면 사용자 경험(UX)과 업무 효율성을 동시에 개선할 수 있음을 배웠습니다.
- 단순히 기능 구현을 넘어서, **성능과 운영 환경을 함께 고려하는 접근**이 필요하다는 점을 깨달았습니다.

### 트러블 슈팅2

**재귀 기반 검사 결과 레포트 다운로드 Progress Bar 구현**

**문제 상황**

- 검사 결과 레포트 다운로드 시 진행률을 파악할 수 없어 대기 시간이 길게 느껴지는 문제가 있었습니다.
- HTML, PDF로 구성된 압축파일 다운로드에 약 **5분(10명 기준)** 이 소요되면서 사용자 불편이 발생했습니다.

**해결 과정**

Back-End 요구사항에 맞춰

**재귀 기반 Progress Bar를 구현**

했습니다.

- 동적 총 페이지 수 확인 및 프로그레스바 초기화
- 재귀 호출마다 실시간 진행률 계산 및 UI 업데이트
- API 에러 발생 시 재시도 메커니즘 적용
- 완료 후 다운로드 링크 자동 생성

**성과**

- 총 페이지 수를 알 수 없는 상황에서도 효율적인 데이터 처리 구조를 마련했습니다.
- 명확한 진행률 표시로 사용자 체감 대기 시간을 단축시켰습니다.
- 운영팀은 진행 상황을 실시간으로 확인할 수 있어 업무 효율성이 향상되었습니다.

**배운점**

- 재귀 호출 기반 로직을 UI/UX에 접목시켜 사용자 경험을 개선할 수 있음을 깨달았습니다.
- 사용자에게 제공되는 정보(진행률, 상태 표시)가 업무 효율성과 만족도에 큰 영향을 준다는 점을 배웠습니다.

### 트러블 슈팅3

**Intersection Observer API 기반 Infinite Scroll 구현**

**문제 상황**

- 응시자-감독 간 실시간 채팅에서 대량의 메시지 데이터 로딩으로 인해 **약 3초간 UI가 프리징**되는 문제가 있었습니다.
- 이는 메인 스레드가 한 번에 많은 데이터를 처리하면서 발생한 UI 블로킹 현상이었습니다.

**해결 과정**

UI 성능 최적화를 위해 react-intersection-observer와

**React Query의 useInfiniteQuery를 도입**

했습니다.

- useInfiniteScrollQuery 커스텀 훅으로 20개 단위 점진적 로딩
- getNextPageParam 기반의 자동 페이지네이션 제어
- useMemo / useCallback을 활용한 불필요한 리렌더링 최소화
- 스켈레톤 UI로 로딩 구간에서 사용자 경험 개선

**성과**

- 초기 렌더링 시간을 **3초 → 0.1초로 97% 단축**

**배운점**

- 기존 스크롤 이벤트 기반 방식은 메인 스레드를 블로킹할 수 있음을 확인했습니다.
- 반면 Intersection Observer는 비동기적으로 동작해 렌더링 성능에 미치는 영향을 최소화할 수 있다는 점을 배웠습니다.
- 앞으로도 대용량 데이터 처리 시 점진적 로딩 전략을 우선적으로 고려해야 함을 깨달았습니다.